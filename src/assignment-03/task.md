Тема. Обробка масивів засобами PHP. Одновимірні масиви

Мета: Ознайомлення з способами ініціалізації масивів. Набуття навичок виконання операцій з масивами та використання функцій для обробки масивів.

 

 

Теоретичні відомості

 

Масиви

 

Насправді масив в PHP – це впорядковане відображення, яке встановлює відповідність між значенням і ключем. Цей тип оптимізований в декількох напрямках, тому його можна використовувати як власне масив, список (вектор), хеш-таблицю (реалізація карти), словник, колекцію, стек, чергу і т.п. Так як значенням масиву може бути інший масив PHP, можна також створювати дерева та багатовимірні масиви.

 

Синтаксис оголошення масивів

 

Визначення за допомогою array ()

 

Масив (тип array ) може бути створений конструкцією array(). Як параметри вона приймає будь-яку кількість розділених комами пар key => value (ключ => значення). Наприклад:

 

array (

     key   => value ,

     key2 => value2 ,

     key3 => value3 ,

   ...

)

 

Кома після останнього елемента масиву необов'язкова і може бути опущена. Зазвичай це робиться для однорядкових масивів, тобто array (1, 2) краще array (1, 2,). Для багаторядкових масивів з іншого боку зазвичай використовується завершальна кома, так як дозволяє легше додавати нові елементи в кінець масиву.

Починаючи з PHP 5.4 можливо використовувати короткий синтаксис визначення масивів, який замінює мовну конструкцію array() на []. Наприклад, простий масив:

 

$array = array(

    "foo" => "bar",

    "bar" => "foo",

);

 

Починаючи з PHP 5.4:

 

$array = [

    "foo" => "bar",

    "bar" => "foo",

];

 

key може бути або типу integer , або типу string. value може бути будь-якого типу.

Додатково з ключем key будуть зроблені наступні перетворення:

·     Рядки, що містять ціле число будуть перетворені до типу integer. Наприклад, ключ із значенням "8" буде в дійсності збережений зі значенням 8. З іншого боку, значення "08" не буде перетворене, так як воно не є коректним десятковим цілим.

·     Числа з плаваючою точкою (тип float ) також будуть перетворені до типу integer, тобто дробова частина буде відкинута. Наприклад, ключ із значенням 8.7 буде насправді збережений з значенням 8.

·     Тип bool також перетворюються до типу integer. Наприклад, ключ із значенням true буде збережений зі значенням 1 і ключ із значенням false буде збережений зі значенням 0.

·     Тип null буде перетворений до порожнього рядка. Наприклад, ключ із значенням null буде насправді збережений зі значенням "".

·     Масиви (тип array) і об'єкти (тип object) не можуть використовуватися в якості ключів. При подібному використанні буде генеруватися попередження: Неприпустимий тип зміщення (Illegal offset type).

Якщо кілька елементів в оголошенні масиву використовують однаковий ключ, то тільки останній буде використовуватися, а все інші будуть перезаписані. Приклад перетворення типів і перезапису елементів:

 

$array = array(

    1    => "a",

    "1"  => "b",

    1.5  => "c",

    true => "d",

);

var_dump($array);

 

Результат виконання даного прикладу:

 

array (1) {

  [1] =>

  string (1) "d"

}

 

Так як всі ключі в наведеному вище прикладі перетворюються до 1 , значення буде перезаписано на кожен новий елемент і залишиться тільки останнім присвоєне значення "d".

Масиви в PHP можуть містити ключі типів integer і string одночасно, так як PHP не робить різниці між індексованими і асоціативними масивами. Нариклад, змішані ключі типів integer і string:

 

$array = array(

    "foo" => "bar",

    "bar" => "foo",

    100   => -100,

    -100  => 100,

);

var_dump($array);

 

Результат виконання даного прикладу:

 

array (4) {

  [ "Foo"] =>

  string (3) "bar"

  [ "Bar"] =>

  string (3) "foo"

  [100] =>

  int (-100)

  [-100] =>

  int (100)

}

 

Параметр key є необов'язковим. Якщо він не вказаний, PHP буде використовувати попереднє найбільше значення ключа типу integer, збільшене на 1. Наприклад, індексовані масиви без ключа:

 

$array = array("foo", "bar", "hello", "world");

var_dump($array);

 

Результат виконання даного прикладу:

 

array (4) {

  [0] =>

  string (3) "foo"

  [1] =>

  string (3) "bar"

  [2] =>

  string (5) "hello"

  [3] =>

  string (5) "world"

}

 

Можливо вказати ключ тільки для деяких елементів і пропустити для інших. Нариклад, ключі для деяких елементів:

 

$array = array(

         "a",

         "b",

    6 => "c",

         "d",

);

var_dump($array);

 

Результат виконання даного прикладу:

 

array (4) {

  [0] =>

  string (1) "a"

  [1] =>

  string (1) "b"

  [6] =>

  string (1) "c"

  [7] =>

  string (1) "d"

}

 

Останнє значення "d" було присвоєно ключу 7. Це сталося через те, що найбільше значення ключа цілого типу перед цим було 6.

 

Доступ до елементів масиву за допомогою квадратних дужок

 

Доступ до елементів масиву може бути здійснений за допомогою синтаксису array [key]. Наприклад:

 

$array = array(

    "foo" => "bar",

    42    => 24,

    "multi" => array(

         "dimensional" => array(

             "array" => "foo"

         )

    )

);

 

var_dump($array["foo"]);

var_dump($array[42]);

var_dump($array["multi"]["dimensional"]["array"]);

 

Результат виконання даного прикладу:

 

string (3) "bar"

int (24)

string (3) "foo"

 

Для доступу до елементів масиву можуть використовуватися як квадратні, так і фігурні дужки (наприклад, $ array [42] і $ array {42}означають одне і те ж в наведеному вище прикладі).

З PHP 5.4 стало можливим пряме розіменування масиву, що повертається в якості результату виклику функції або методу. Раніше доводилося використовувати тимчасові змінні.

З PHP 5.5 стало можливим пряме розіменування елементів у літерали масиву. Приклад розіменування масиву:

 

function getArray() {

    return array(1, 2, 3);

}

 

// в PHP 5.4

$secondElement = getArray()[1];

 

// ранішше записували так

$tmp = getArray();

$secondElement = $tmp[1];

 

// або так

list(, $secondElement) = getArray();

 

Спробу ініціалізувати невизначений ключ в масиві – це те ж саме, що і спроба доступу до будь-якої іншої невизначеною змінної: буде згенерована помилка рівня E_NOTICE, і результат буде NULL.

 

Створення/модифікація за допомогою синтаксису квадратних дужок

 

Існуючий масив може бути змінений явною установкою значень в ньому. Це виконується присвоєнням значень масиву array із зазначенням в дужках ключа. Крім того, ви можете опустити ключ. В цьому випадку слід додати до імені змінної порожню пару дужок ( [] ).

 

    $ arr [ key ] = value ;

    $ arr [] = value ;

    // Key може бути integer або string

    // value може бути будь-яким значенням будь-якого типу

 

Якщо масив $ arr ще не існує, він буде створений. Таким чином, це ще один спосіб визначити масив array. Однак такий спосіб застосовувати не рекомендується, так як якщо змінна $arr вже містить деяке значення (наприклад, значення типу string з змінною запиту), то це значення залишиться на місці і [] може насправді означати доступ до символу в рядку. Краще ініціалізувати змінну шляхом явного присвоєння значення.

Для зміни певного значення слід надати нове значення елемента, використовуючи його ключ. Якщо потрібно видалити пару ключ/значення, необхідно використовувати функцію unset ().

 

$arr = array(5 => 1, 12 => 2);

 

$arr[] = 56;    // В цьому місці скрипта це

                // те ж саме, що й $arr[13] = 56;

 

$arr["x"] = 42; // Це добавляє до масиву новый

                // элемент з ключем "x"

            

unset($arr[5]); // Це видаляє элемент з масиву

 

unset($arr);    // Це видаляє масив повністью

 

Як вже було описано вище, якщо ключ не був зазначений, то буде використано максимальний з існуючих цілочисельних (integer) індексів, і новим ключем буде це максимальне значення (в крайньому випадку 0) плюс 1. Якщо цілочисельних індексів ще немає, то ключем буде 0 (нуль).

Слід врахувати, що максимальне ціле значення ключа не обов'язково існує в масиві в даний момент. Воно могло просто існувати в масиві якийсь час, з тих пір як він був переіндексувати в останній раз. Наступний приклад це ілюструє:

 

// Створюємо простий масив.

$array = array(1, 2, 3, 4, 5);

print_r($array);

 

// Тепер видаляємо кожен елемент, але сам масив залишаємо порожнім:

foreach ($array as $i => $value) {

    unset($array[$i]);

}

print_r($array);

 

// Додаємо елемент

// (зверніть увагу, що новим ключем буде 5, замість 0).

$array[] = 6;

print_r($array);

 

// Переіндексація:

$array = array_values($array);

$array[] = 7;

print_r($array);

 

Результат виконання даного прикладу:

 

Array

(

    [0] => 1

    [1] => 2

    [2] => 3

    [3] => 4

    [4] => 5

)

Array

(

)

Array

(

    [5] => 6

)

Array

(

    [0] => 6

    [1] => 7

)

 

Корисні функції

 

Для роботи з масивами існує достатня кількість корисних функцій.

Функція unset () дозволяє видаляти ключі масиву. Зверніть увагу, що масив НЕ буде переіндексовуватись. Якщо потрібно виконати дії "видалити і змістити", можна переіндексувати масив використовуючи array_values().

 

$a = array(1 => 'один', 2 => 'два', 3 => 'три');

unset($a[2]);

/* поверне масив, представлений так:

   $a = array(1 => 'один', 3 => 'три');

// а не так:

   $a = array(1 => 'один', 2 => 'три');

*/

 

$b = array_values($a);

// Тепер $b це array(0 => 'один', 1 => 'три')

 

Керуюча конструкція foreach існує спеціально для масивів. Вона надає можливість пройтися по масиву.

 

Що можна і не можна робити з масивами

 

Чому $ foo [bar] невірно?

 

Строковий літерал в індексі асоціативного масиву завжди слід вміщувати в лапки. Наприклад, слід писати $foo['bar'] , а не $foo[bar]. Але чому? Часто в старих скриптах можна зустріти наступний синтаксис:

 

$foo[bar] = 'ворог';

echo $foo[bar];

// і т.д.

 

Це неправильно, але це працює. Причина полягає в тому, що цей код має невизначену константу (bar), а не рядок ('bar' – зверніть увагу на лапки). PHP в майбутньому може визначити константу, яка має таке ж ім’я. Це працює, тому що PHP автоматично перетворює Abare рядок (вміщений в лапки рядок, який не відповідає жодному з відомих символів) в рядок, який містить порожній рядок. Наприклад, якщо немає певної константи з ім'ям bar, то PHP замінить 'bar' на рядок. Це не означає, що потрібно завжди вміщувати ключ в лапки. Немає необхідності брати в лапки константи або змінні, оскільки це перешкодить PHP їх обробляти. Наприклад:

 

error_reporting(E_ALL);

ini_set('display_errors', true);

ini_set('html_errors', false);

// Простий массив:

$array = array(1, 2);

$count = count($array);

for ($i = 0; $i < $count; $i++) {

    echo "\nПеревіряємо $i: \n";

    echo "Погано: ". $array['$i']. "\n";

    echo "Добре: ". $array[$i]. "\n";

    echo "Погано: {$array['$i']}\n";

    echo "Добре: {$array[$i]}\n";

}

 

Результат виконання прикладу:

 

Перевіряємо 0:

Notice: Undefined index: $ i in /path/to/script.html on line 9

погано:

Добре: 1

Notice: Undefined index: $ i in /path/to/script.html on line 11

погано:

Добре: 1

 

Перевіряємо 1:

Notice: Undefined index: $ i in /path/to/script.html on line 9

погано:

Добре: 2

Notice: Undefined index: $ i in /path/to/script.html on line 11

погано:

Добре: 2

 

Додаткові приклади, що демонструють цей факт:

 

error_reporting(E_ALL);//Показуємо всі помилки

$arr = array('fruit' => 'apple', 'veggie' => 'carrot');

//Правильно

print $arr['fruit'];  // apple

print $arr['veggie']; // carrot

//Невірно. Це працює, але через невизначену константи з

//ім'ям fruit також викликає помилку PHP рівня E_NOTICE

//Примітка: Використання невизначена константа fruit - //передбачається, 'fruit' в ...

print $arr[fruit];// apple

//Визначимо константу, щоб продемонструвати, що відбувається.

//Дамо константі з ім'ям fruit значення 'veggie'.

define('fruit', 'veggie');

//Тепер зверніть увагу на різницю

print $arr['fruit'];//apple

print $arr[fruit];//carrot

//Усередині рядка це нормально. Всередині рядків константи

//розглядаються, так що помилки E_NOTICE тут не відбудеться

print "Hello $arr[fruit]";      // Hello apple

//За одним винятком: фігурні дужки навколо масивів всередині

//рядків дозволяють констант там перебувати

print "Hello {$arr[fruit]}";  // Hello carrot

print "Hello {$arr['fruit']}";// Hello apple

//Це не буде працювати і викличе помилку обробки, таку як:

//Parse error: parse error, expecting T_STRING' or T_VARIABLE' or //T_NUM_STRING'

// Це, звичайно, також діє з супер глобальними змінними в рядках

print "Hello $arr['fruit']";

print "Hello $_GET['foo']";

//Ще одна можливысть – конкатенація

print "Hello ". $arr['fruit']; // Hello apple

 

Якщо перекласти error_reporting в режим відображення помилок рівня E_NOTICE (наприклад, таких як E_ALL), можна побачити ці помилки. За замовчуванням error_reporting встановлена їх не відображати.

Як зазначено в розділі синтаксис, всередині квадратних дужок ('['і']') має бути вираз. Це означає, що можна писати ось так:

 

echo $arr[somefunc($bar)];

 

Це приклад використання в якості індекса масиву значення повернутого функцією. В якості індекса масиву PHP можна використовувати константи:

 

$error_descriptions[E_ERROR]="Сталася фатальна помилка";

$error_descriptions[E_WARNING]="PHP повідомляє про попередження";

$error_descriptions[E_NOTICE]="Це лише неофіційне зауваження";

 

E_ERROR – це також ідентифікатор, як bar в попередньому прикладі. Але останній приклад по суті еквівалентний такому запису:

 

$error_descriptions[1]="Сталася фатальна помилка";

$error_descriptions[2]="PHP повідомляє про попередження";

$error_descriptions[8]="Це лише неофіційне зауваження";

 

оскільки E_ERROR відповідає 1 , і т.д.

 

Чому не слід використовувати описані вище конструкції?

При подальшій модифікації скриптів, команда розробників PHP, можливо, забажає додати ще одну константу або ключове слово, або може втрутитися константа з іншого коду. Наприклад, не можна використовувати подібним чином слова empty і default , оскільки вони є зарезервованими ключовими словами.

Всередині рядка (string), вміщеного в подвійні лапки, коректно не вкладати індекси масиву в лапки, тому "$foo[bar]" є вірною записом.

 

Перетворення в масив

 

Для будь-якого з типів: integer, float, string, boolean і resource, перетворення значення в масив дає результатом масив з одним елементом (з індексом 0). Іншими словами, (array)$scalarValue – це те ж саме, що і array($scalarValue).

Якщо перетворити в масив об'єкт (object), отримаємо в якості елементів масиву властивості (змінні-елементи) цього об'єкта. Ключами будуть імена змінних-елементів, з деякими винятками: цілочисельні властивості стануть недоступні; до закритих полів класу (private) на початку буде дописано ім'я класу; до захищених полів класу (protected) спереду буде додано символ '*'. Ці додані значення з обох сторін також мають нульові байти. Це може викликати дещо несподівану поведінку:

 

 

class A {

    private $A; // Це стане '\0A\0A'

}

 

class B extends A {

    private $A; // Це стане '\0B\0A'

    public $AA; // Це стане 'AA'

}

 

var_dump((array) new B());

 

Вищенаведений код покаже 2 ключі з ім'ям 'AA', хоча один з них насправді має ім'я '\ 0A \ 0A'. Якщо перетворити в масив значення NULL, отримаємо порожній масив.

 

Порівняння масивів

 

Масиви можна порівнювати за допомогою функції array_diff() і оператори масивів. Наприклад:

 

// это

$a = array( 'color' => 'red',

            'taste' => 'sweet',

            'shape' => 'round',

            'name'  => 'apple',

            4        // ключом буде 0

          );

 

$b = array('a', 'b', 'c');

 

//... повністю відповідає

$a = array();

$a['color'] = 'red';

$a['taste'] = 'sweet';

$a['shape'] = 'round';

$a['name']  = 'apple';

$a[]        = 4;        // ключом буде 0

 

$b = array();

$b[] = 'a';

$b[] = 'b';

$b[] = 'c';

 

//після виконання цього коду, $ а буде масивом

// array('color' => 'red', 'taste' => 'sweet', 'shape' => 'round',

// 'name' => 'apple', 0 => 4), а $b будет

// array(0 => 'a', 1 => 'b', 2 => 'c'), или просто array('a', 'b', 'c').

 

Приклад використання array ()

 

//Масив як карта (властивостей)

$map = array( 'version'    => 4,

              'OS'         => 'Linux',

              'lang'       => 'english',

              'short_tags' => true

            );

        

//виключно числові ключі

$array = array( 7,

                8,

                0,

                156,

                -10

              );

//це те ж саме, що й array(0 => 7, 1 => 8,...)

 

$switching = array(         10, // ключ = 0

                    5    =>  6,

                    3    =>  7,

                    'a'  =>  4,

                            11, // ключ = 6 (максимальним числовим

//індексом було 5)

                    '8'  =>  2, // ключ = 8 (число!)

                    '02' => 77, // ключ = '02'

                    0    => 12  // значення 10 буде перезаписано

//на 12

                  );

               

// пустий масив

$empty = array();     

 

Приклад колекції кольорів:

 

$colors = array('red', 'blue', 'green', 'yellow');

 

foreach ($colors as $color) {

    echo "Вам подобається $color?\n";

}

 

Результат виконання прикладу:

 

Вам подобається red?

Вам подобається blue?

Вам подобається green?

Вам подобається yellow?

 

Зміна значень масиву безпосередньо стала можливою починаючи з версії PHP 5 шляхом передачі їх по посиланню. До цього необхідний наступний обхідний прийом:

 

<?PHP

//PHP 5

foreach ($colors as &$color) {

    $color = strtoupper($color);

}

unset($color); /* це потрібно для того, щоб наступні записи в

$color не змінювали останній елемент масиву */

 

//Обхідний прийом для старих версій

foreach ($colors as $key => $color) {

    $colors[$key] = strtoupper($color);

}

 

print_r($colors);

 

Результат виконання прикладу:

 

Array

(

    [0] => RED

    [1] => BLUE

    [2] => GREEN

    [3] => YELLOW

)

 

Наступний приклад створює масив, що починається з одиниці:

 

$firstquarter  = array(1 => 'Січень', 'Лютий', 'Березень');

print_r($firstquarter);

 

Результат виконання прикладу:

 

Array

(

    [1] => 'січень'

    [2] => 'лютий'

    [3] => 'березень'

)

 

Приклад заповнення масиву:

 

//заповнити масив усіма елементами з каталогу

$handle = opendir('.');

while (false !== ($file = readdir($handle))) {

    $files[] = $file;

}

closedir($handle);

 

Масиви впорядковані. Можна змінювати порядок елементів, використовуючи різні функції сортування. Можна підрахувати кількість елементів в масиві за допомогою функції count (). Приклад сортування масиву:

 

sort($files);

print_r($files);

 

Оскільки значення масиву може бути чим завгодно, ним також може бути інший масив. Таким чином можна створювати рекурсивні та багатовимірні масиви. Приклад рекурсивного та багатовимірного масиву:

 

$fruits = array ( "фрукти"  => array ( "a" => "апельсин",

                                       "b" => "банан",

                                       "c" => "яблуко"

                                     ),

                  "числа"   => array ( 1,

                                       2,

                                       3,

                                       4,

                                       5,

                                       6

                                     ),

                  "отвори"   => array (     "перший",

                                       5 => "другий",

                                            "третій"

                                     )

                );

 

//декілька прикладів доступу до значень попереднього масиву

echo $fruits["отвори"][5];  //виведе "другий"

echo $fruits["фрукты"]["a"]; //виведе "апельсин"

unset($fruits["отвори"][0]);  //видалить "перший"

 

//Створить новий багатовимірний масив

$juices["apple"]["green"] = "good";

 

При присвоєнні елемента масиву завжди відбувається копіювання значення. Щоб скопіювати масив за посиланням, потрібно використовувати оператор посилання.

 

$arr1 = array(2, 3);

$arr2 = $arr1;

$arr2[] = 4; // $arr2 змінився,

             // $arr1 все еще array(2, 3)

         

$arr3 = &$arr1;

$arr3[] = 4; // тепер $arr1 и $arr3 одинакові

 

Функції для обробки масивів

 

array_change_key_case – Змінює регістр всіх ключів в масиві.

array_chunk – Розбиває масив на частини.

array_column – Повернення значень з одного стовпця в вхідному масиві.

array_combine – Створює новий масив, використовуючи один масив в якості ключів, а інший в якості відповідних значень.

array_count_values – Підраховує кількість всіх значень масиву.

array_diff_assoc – Обчислює розбіжність масивів з додатковою перевіркою індексу.

array_diff_key – Обчислює розбіжність масивів, порівнюючи ключі.

array_diff_uassoc – Обчислює розбіжність масивів з додатковою перевіркою індексу, що здійснюється за допомогою callback-функції.

array_diff_ukey – Обчислює розбіжність масивів, використовуючи callback-функцію для порівняння ключів.

array_diff – Обчислити розбіжність масивів.

array_fill_keys – Створює масив і заповнює його значеннями, з певними ключами.

array_fill – Заповнює масив значеннями.

array_filter – Фільтрує елементи масиву за допомогою callback-функції.

array_flip – Міняє місцями ключі з їх значеннями в масиві.

array_intersect_assoc – Обчислює сходження масивів з додатковою перевіркою індексу.

array_intersect_key – Обчислити перетин масивів, порівнюючи ключі.

array_intersect_uassoc – Обчислює сходження масивів з додатковою перевіркою індексу, що здійснюється за допомогою callback-функції.

array_intersect_ukey – Обчислює сходження масивів, використовуючи callback-функцію для порівняння ключів.

array_intersect – Обчислює сходження масивів.

array_key_exists – Перевіряє, чи присутній в масиві вказаний ключ або індекс.

array_keys – Повертає всі або деяку підмножину ключів масиву.

array_map – Застосовує callback-функцію до всіх елементів зазначених масивів.

array_merge_recursive – Рекурсивне злиття двох або більше масивів.

array_merge – Зливає один або більшу кількість масивів.

array_multisort – Сортує кілька масивів або багатовимірні масиви.

array_pad – Доповнює масив певним значенням до заданої величини.

array_pp – Витягує останній елемент масиву.

array_prduct – Обчислити добуток значень масиву.

array_push – Додає один або кілька елементів в кінець масиву.

array_rand – Вибирає одне або кілька випадкових значень з масиву.

array_reduce – Ітеративне зменшення масиву до єдиного значенням, використовуючи callback-функцію

array_replace_recursive – Рекурсивно замінює елементи першого масиву елементами переданих масивів.

array_replace – Заміна елементів масиву елементами інших переданих масивів.

array_reverse – Повертає масив з елементами в зворотному порядку.

array_search – Здійснює пошук даного значення в масиві і повертає відповідний ключ в разі успіху.

array_shift – Витягує перший елемент масиву.

array_slice – Вибирає зріз масиву.

array_splice – Видаляє частину масиву і замінює її чимось ще.

array_sum – Обчислює суму значень масиву.

array_udiff_assoc – Обчислює розбіжність в масивах з додатковою перевіркою індексів, використовуючи для порівняння значень callback-функцію.

array_udiff_uassoc – Обчислює розбіжність в масивах з додатковою перевіркою індексів, використовуючи для порівняння значень і індексів callback-функцію.

array_udiff – Обчислює розбіжність масивів, використовуючи для порівняння callback-функцію.

array_uintersect_assoc – Обчислює перетин масивів з додатковою перевіркою індексів, використовуючи для порівняння значень callback-функцію.

array_uintersect_uassoc – Обчислює перетин масивів з додатковою перевіркою індексу, використовуючи для порівняння індексів і значень callback-функцію.

array_uintersect – Обчислює перетин масивів, використовуючи для порівняння значень callback-функцію.

array_unique – Прибирає повторювані значення з масиву.

array_unshift – Додає один або кілька елементів в початок масиву.

array_values – Вибирає всі значення масиву.

array_walk_recursive – Рекурсивно застосовує для користувача функцію до кожного елементу масиву.

array_walk – Застосовує задану користувачем функцію до кожного елементу масиву.

array – Створює масив.

arsort – Сортує масив в зворотному порядку, зберігаючи ключі.

asort – Сортує масив, зберігаючи ключі.

compact – Створює масив, що містить назви змінних і їх значення.

count – Підраховує кількість елементів масиву або щось в об'єкті.

current – Повертає поточний елемент масиву.

each – Повертає поточну пару ключ / значення з масиву і зміщує його покажчик.

end – встановлює внутрішній покажчик масиву на його останній елемент.

extract – Імпортує змінні з масиву в поточну таблицю символів.

in_array – Перевіряє, чи присутній в масиві значення.

key_exists – Ім'я користувача array_key_exists.

key – Вибирає ключ з масиву.

krsort – Сортує масив по ключам у зворотному порядку.

ksort – Сортує масив по ключам.

list – Надає змінним зі списку значення подібно масиву.

natcasesort – Сортує масив, використовуючи алгоритм "natural rder" без обліку регістра символів.

natsort – Сортує масив, використовуючи алгоритм "natural rder".

next – пересуває внутрішній покажчик масиву на одну позицію вперед.

pos – Ім'я користувача current.

prev – пересуває внутрішній покажчик масиву на одну позицію назад.

range – Створює масив, що містить діапазон елементів

reset – встановлює внутрішній покажчик масиву на його перший елемент

rsort – Сортує масив в зворотному порядку

shuffle – Перемішує масив

sizef – Ім'я користувача cunt

sort – Сортує масив

uasort – Сортує масив, використовуючи призначену для користувача функцію для порівняння елементів зі збереженням ключів

uksort – Сортує масив по ключам, використовуючи призначену для користувача функцію для порівняння ключів

usort – Сортує масив по значенням використовуючи призначену для користувача функцію для порівняння елементів

 

 

Завдання

 

Створити Web-документ для для розв’язування задачі відповідного варіанта згідно з умовою. Варіант вибирається відповідно до вашого номера в журналі). Для зберігання наборів проміжних значень використати масиви. Вхідною інформацією є знання одного з масивів:

А = {-9; 7; 8; 0; -1; 6; -4; 5; 0; 5};

В = {5; 4; 7; 6; -3; -2; -5; 0; 9; -5};

С = {0; 5; 0; -4; 0; 7; 8; 0; -5; 9};

D = {6; 8; 12; -5; 4; 3; -8; 1; 8; 5};

Е = {-3; 0; -2; 0; -6; 1; 0; -5; 0; 7};

Обчислювану формулу вивести у web-документі у вигляді рисунка.

Обчислені значення вивести в окремих блоках div.

У web-документі засобами PHP додатково вивести інформацію про розробника (група, прізвище, ім’я, по батькові), дату створення документу, поточну дату.

Web-документ зберегти та розмістити в окремому каталозі на хостингу, зареєстрованому в лабораторній роботі №2 з попереднього семестру.

Варіант завдання:

4. Обчислити добуток елементів масиву Д. Якщо цей добуток є додатним, то добути в нього корінь квадратний, а якщо є від’ємним то корінь кубічний. Обчислити новий масив, елементи якого дорівнюють добуткам отриманого результату на значення елементів масиву Д. Знайти кількість від’ємних елементів у новому масиві та їх координати.