Тема: Створення форм. Обробка даних отриманих від форм засобами PHP. Регулярні вирази.

Мета: Ознайомлення з особливостями генерації HTML-форм засобами PHP, способам передачі даних з екранних форм в PHP-сценарії та особливостями їх обробки з використанням регулярних виразів

Теоретичні відомості

HTML-форми

Найчастіше на веб-сайтах можна зустріти сторінки з розміщеними на них HTML-формами. Веб-форми – зручний спосіб отримання інформації від відвідувачів сайту. Прикладом може бути гостьова книга, яка забезпечує зворотній зв'язок з відвідувачами та розробниками сайту. Форми зручні для розробників сайту при розробці CMS, яка дозволяє підтримувати головну властивість сайту – актуальність

1. Створення простої форми

Теги <form> і </ form> задають початок і кінець форми. Початковий тег форми <form> містить два атрибути: action і method. Атрибут action містить URL-адресу сценарію, який має бути викликаний для обробки сценарію. Атрибут method вказує браузеру, який вид HTTP запиту необхідно використовувати для відправки форми; можливі значення POST і GET.

Приклад:

<form method="post" action="../admin/add_story.php">

... ... ...

</form>

Примітка:

Головна відмінність методів POST і GET полягає в способі передачі інформації. У методі GET параметри передаються через адресний рядок, тобто по суті в HTTP-заголовку запиту, в той час як в методі POST параметри передаються через тіло HTTP-запиту і ніяк не відображаються на вигляді адресного рядка.

2. Прапорець (checkbox)

Прапорці checkbox пропоную користувачеві ряд варіантів, і дозволяє вибір кількох з них.

<input name="Ім'я перемикача" type="Тип" value="Значення">

Група прапорців складається з елементів <input>, що мають однакові атрибути name і type (checkbox). Якщо ви хочете, щоб елемент був відзначений за замовчуванням необхідно позначити його як checked. Якщо елемент обраний, то до сценарієм буде надіслано рядок ім'я = значення, в іншому випадку в обробник форми не буде надіслано нічого, тобто не вибрані прапорці взагалі ніяк не проявляють себе в переданому наборі даних.

Приклад:

<input name="mycolor" type="checkbox" value="red" checked>Червоний (вибраний по замовчуванню)

<input name="mycolor" type="checkbox" value="blue">Синій

<input name="mycolor" type="checkbox" value="black">Чорний

<input name="mycolor" type="checkbox" value="white">Білий

3. Перемикач (radio)

Перемикачі radio пропонують користувачеві ряд варіантів, але дозволяє вибрати тільки один з них.

<input name="Ім'я перемикача" type="Тип" value="Значення">

Перемикач (radio) має атрибути name, type і value. Атрибут name задає ім'я перемикача, type задає тип radio, а атрибут value задає значення. Якщо користувач вибере перемикач, то сценарієм буде передана рядок ім'я = значення. При необхідності можна вказати параметр checked, який вказує на те, що перемикач буде мати фокус (тобто буде відзначений за замовчуванням) при завантаженні сторінки. Перемикачі також можна об'єднувати в групи, для цього вони повинні мати одне і теж ім'я.

Приклад:

<input name="mycolor" type="radio" value="white">Білий

<input name="mycolor " type="radio" value="green" checked> Зелений (вибраний по замовчуванню)

<input name="mycolor " type="radio" value="blue"> Синій

<input name="mycolor " type="radio" value="red"> Червоний

<input name="mycolor " type="radio" value="black"> Чорний

4. Випадаючий список (select)

Тег <select> являє собою випадаючий або розкритий список, при цьому одночасно можуть бути обрані одна або кілька рядків.

Список починається з парних тегів <select> </ select>. Теги <option> </option> дозволяють визначити вміст списку, а параметр value визначає значення рядка. Якщо в тегові <option> вказаний параметр selected, то рядок спочатку буде вибраним. Параметр size задає, скільки рядків буде займати список. Якщо size дорівнює 1, то список буде випадаючим. Якщо вказаний атрибут multiple, то дозволено вибирати кілька елементів зі списку (при size = 1 не має сенсу).

Приклад:

<select name="Ім'я списку" size = “Розмір” multiple>

<option value=”Значення”>Текст що відображаєтся в списку</option>

</select>

При передачі даних списку сценарієм передається рядок ім'я = значення, а при розкритому списку передається рядок ім'я = значення1 & ім'я = значення2 & ім'я = значенняN.

5. Текстове поле (text)

Дозволяє користувачам вводити різну інформацію.

<input type="Тип" name="Ім'я поля" size="Розмір "maxlength="Макс. символів">

При створенні звичайного текстового поля розміром size і максимальної допустимої довжини maxlength символів, атрибут type приймає значення text. Якщо вказаний параметр value, то поле буде містити(відображати) value-текст. При створенні поля не забувайте вказувати ім'я поля, тому що цей атрибут є обов'язковим.

Приклад:

<input type="text" name="txtName" size="10" maxlength="5" value="Текст по замовчуванню">

6. Поле для введення пароля (password)

Повністю аналогічний текстовому полю, за винятком того що символи, що набираються користувачем, не будуть відображатися на екрані.

Приклад:

<input type="password" name="txtName" size="10" maxlength="5">

7. Багаторядкове поле для введення тексту (textarea)

Багаторядкове поле для введення тексту дозволяє відправляти відразу декілька рядків. За замовчуванням тег створює порожнє поле шириною в 20 символів і складається з двох рядків.

<textarea name="Ім'я поля" cols="Ширина поля" rows="Число рядків"> Текст </textarea>

Багаторядкове поле введення тексту починається з парних тегів <textarea> </ textarea>. Тег name задає ім'я багаторядкового поля. Також можна вказати ширину поля (cols) і число рядків (rows). При необхідності можна вказати атрибут readonly, який забороняє редагувати, видаляти і змінювати текст, тобто текст буде призначений тільки для читання. Якщо необхідно щоб текст був спочатку відображений в багаторядковому поле введення, то його необхідно помістити між тегами <textarea></ textarea>.

Приклад:

<textarea name="txtArea" cols="15" rows="10" readonly> Текст, котрий будет зразу відображений в багаторядковому полі вводу і которий не можна змінювати, оскільки вказаний атрибут readonly </textarea>

8. Приховане текстове поле

Дозволяє передавати сценарієм якусь службову інформацію, не відображаючи її на сторінці.

<input name="Ім'я" type="Тип" value="Значення">

Приховане поле починається з тега <input>, атрибути якого є name, type і value. Атрибут name задає ім'я поля, type визначає тип поля, а атрибут value задає значення поля.

Приклад:

<input name="email" type="hidden" value="spam@nospam.com">

9. Кнопка для завантаження файлів (browse)

Служить для реалізації завантаження файлів на сервер. Об'єкт browse начитається з парних тегів <form> </ form>. Початковий тег <form> містить необхідний атрибут encrypt. Атрибут encrypt приймає значення

multipart/form-data, який сповіщає сервер про те, що разом зі звичайною інформацією надсилається файл. При створенні текстового поля також необхідно вказати тип файлу – "file".

<form enctype="multipart/form-data" action="upload.php" method="post">

Завантажити файл: <input name="my_file" type="file">

<input type="submit" value="Надіслати">

</form>

12. Рамка (fieldset)

Об'єкт fieldset дозволяє намалювати рамку навколо об'єктів. Має закриваючий тег </fieldset>. Тема вказується в тегах <legend> </ legend>. Основне призначення об'єкта – задавание різних стилів оформлення.

Приклад:

<fieldset>

<legend>Програмне забезпечення(заголовок рамки)</legend>

Текст, которий будет поміщений всередині рамки.</fieldset>

10. Кнопка скидання форми (Reset)

<input type=" Тип "name="Ім'я кнопки" value="Напис на кнопці">

При натисканні на кнопку скидання (reset), всі елементи форми будуть встановлені в той стан, який було задано в атрибутах за замовчуванням, причому відправка форми не буде проводитись.

Приклад:

<input type="reset" name="Reset" value="Очистити форму">

10. Кнопка відправки форми (submit)

Служить для відправки форми сценарієм.

<input type="Тип "name="Ім'я кнопки" value="Текст кнопки">

При створенні кнопки для відправки форми необхідно вказати 2 атрибута: type = "submit" і value = "Текст кнопки". Атрибут name необхідний якщо кнопка не одна, а декілька і всі вони створені для різних операцій, наприклад кнопки "Зберегти", "Видалити", "Редагувати" і т.д. Після натискання на кнопку сценарієм передається рядок ім'я = текст кнопки.

PHP та регулярні вирази

Регулярні вирази у відриві від їхньої конкретної реалізації

Регулярні вирази (що позначаються англійською як RegEx або як regex ) – інструментальний засіб, який застосовується пошуку, перевірки, пошуку та заміни елемента, що складається з букв, цифр або будь-яких інших символів (в тому числі спеціальних символів та символів пунктуації). Спочатку регулярні вислови увійшли в світ програмування з середовища наукових досліджень, які проводилися в 50-ті роки в галузі математики.

У PHP регулярні вирази використовуються для синтаксичного аналізу тексту відповідно до визначеного шаблону. Використовуючи регулярні вирази, можна легко знайти за шаблоном потрібний текст в рядку, і замінити його, якщо потрібно, або просто зробити перевірку на наявність такого тексту.

Принципи та ідеї регулярних виразів були перенесені в середовище операційної системи UNIX. Зокрема увійшли до утиліти grep та були реалізовані в мові програмування Perl.

Будь-який вираз може бути «регулярним» і застосовуватись для перевірки чи пошуку будь-яких символів. Наприклад, слова Pavel або example@server.com можуть використовуватися як регулярні вирази. Тільки у досить вузькому контексті. Для перевірки роботи регулярних виразів у середовищі PHP без запуску свого сервера або хостингу можна скористатися онлайн сервісом [https://regex101.com/]. Але на ньому не працювала обробка кирилічних символів.

Варіативність регулярного виразу

Якщо регулярний вираз варіативний (наприклад, відома лише деяка його частина і потрібно знайти кількість входжень років, починаючи від 2000 і закінчуючи 2099), то можна використовувати регулярний вираз:

20.

В тексті:

Публікації в царині інформаційних технологій суттєво прогресують по роках. Наприклад публікації 2002 року дуже суттєво відрізняються від 2008 і 2012.

Відповідності зазначеному регулярному виразу позначені потовщеним шрифтом.

Екранування

Уявімо, що потрібно знайти кількість входжень файлів з розширенням .doc. Але ж крапка означає просто будь-який символ? То як же бути?

Тут до нас на допомогу розробникам приходить екранування метасимволів зворотним слешем \. Зокрема вираз \.doc буде шукати будь-яку відповідність з розширенням .doc. Регулярний вираз:

\.doc

Наприклад, текст:

file_name.doc

Однак це не дозволить видобути повні імена файлів за допомогою цього регулярного виразу в масив.

Збіг з цілим набором символів

У регулярних виразах збіги з набором символів забезпечується за допомогою метасимволів – квадратних дужок [ ]. Будь-які два ASII-символи можуть бути вказані для початку та кінця діапазону.

Регулярний вираз:

[0-9]\.jpg

може бути використано для простої реалізації коли потрібно знайти всі пронумеровані файли від 0 до 9 з розширенням .jpg. Текст:

1.jpg , 2.jpg , 3.jpg , photo.jpg, anime.jpg, 8.jpg , jkl.jpg

Слід відзначити, що ім'я файлів з більш ніж 1 цифри даний регулярний вираз не охопить. Якщо потрібно досягнути зворотного результату, то слід додати метасимвол ^. У нього в регулярних виразих є дві функції. Щоб скористатися ним як винятком, потрібно додати цей символ саме всередину набору. Наприклад, регулярний вираз:

[^0-9]\.jpg

Виділить текст :

Files named 1.jpg 2.jpg , 3.jpg

Таблиця 1 – Таблиця метасимволів

Символ

Призначення

\


Екранувати метасимвол як звичайний символ

^

1. Шукати певний символ саме на початку рядка

2. Виключити його з набору []

$

Кінець рядка

|

Альтернатива

()

Групування

\in

Всі буквенні та цифрові символи

\IN

Все крім буквенних та цифрових символів

\s

Будь-який пробіловий символ

\S

Будь-який НЕ пробельний символ

Таблиця 2 – Таблиця пробільних метасимволів

Символ

Призначення

[\b]

Повернення на один символ

\f

Перевід сторінки

\n

Перевід рядка

\r

Повернення каретки

\t

Табулювання

\v

Вертикальна табуляція

Множинний вибір

Спробуємо сформувати регулярний вираз, який знаходить, наприклад, слова коротші за 3 букви. Якщо використовувати регулярний вираз:

\w{1,3}

у якому метасимвол \w вказує на будь-який символ, а фігурні дужки позначають кількість символів від скільки до скільки, то виділяться всі символи поспіль. Тому потрібно якось позначити початок і кінець слів у тексті. Для цього знадобиться метасимвол \b. Наприклад, регулярний вираз:

\b\w{1,3}\b:

виділить в тексті:

good word not egg

Тепер слова коротші за три літери не зможуть потрапляти до вибірки.

Регулярний вираз для перевірки електронної пошти:

\w+@\w+\.\w+

В електронній пошті на початку має бути будь-який символ (цифри або буква. Потім йде символ @, потім скільки завгодно символів, після чого екранована крапка і домен першого рівня.

Повторення символів

Розглянемо детальніше, як можна в регулярних виразах задати повторення символів. Наприклад, потрібно знайти будь-які комбінації цифр від 2 до 6 у тексті. Для цього знадобиться регулярний вираз:

[2-6]+

Текст:

Here are come's 89 different 234 digits 24 .

Таблиця 3 – Квантифікатори метасимволів

Символ

Призначення

-

Символи повторюються 0 і до нескінченності

-

Символи повторюються 0 і до нескінченності

-

Повторюються від 1 до нескінченності

{n}

Повторюються точно n разів

{n,}

Від n і до нескінченності

{n1, n2}

Від n1 і до n2 разів точно

?

0 або 1 символ, не більше

У застосуванні квантифікаторів немає нічого складного. Крім одного нюансу: жадібні та ліниві квантифікатори. Наведемо таблицю:

Таблиця 4 – Жадібні та ліниві квантифікатори

Жадібні\*

Ліниві

-   \*?

*   +?

{n,}

{n,}?

Ліниві квантифікатори відрізняються від жадібних тим, що вони вихоплюють мінімальну, а не максимальну кількість символів. Уявімо, що потрібно знайти всі теги заголовків h1-h6 та їх контент, а весь решта тексту не повинен бути порушений. Для цього потрібно використати регулярний вираз:

<h[1-6]>.\*?<\/h[1-6]>

Текст:

<h6>hello</h6>lorem ipsum avada kedavra <h6> buy</h6>

Він спрацює успішно завдяки лінивому квантифікатору. Коли застосувати жадібний квантифікатор буде виділено весь текст між тегами.

Межі символьних рядків

Межі символьних рядків використовувались вище. Наведемо докладнішу таблицю.

Таблиця 5 – Межі символьних рядків

Символ

Призначення

\b

межа слова

\B

не межа слова

\А

початок рядка

\ВІД

кінець рядка

\G

кінець дії

Робота з підвиразами

Підвирази в регулярних виразах формуються за допомогою метасимволів груповання (). Приклад регулярного виразу, який універсально може знаходити різні варіації [?]IP-адрес[/?]:

(((25[0-5])|(2[0-4]\d)|(1\d{2})|(\d{1,2}))\.){3} (((25[0-5]|(2[0-4]\d)|(1\d{2})|(\d{1,2})))))

Текст:

255.255.255.255 просто адреса

191.198 .174.192 wikipedia

31.13.72.36 facebook

Тут використовується логічний оператор | (або), який дозволяє скласти регулярний вираз, що відповідає правилу, за яким складаються [?]IP-адрес[/?]и. Зокрема, в IP адресі має бути від 1 і до 3 цифр. Перше число може починатися з 1 або 2. Або друга цифра має бути в межах від 0 і до 4, або починатися з 25, і тоді 3 цифра виявляється в межах від 0 до 5. Також між кожною комбінацією цифр повинна бути крапка.

Пошук з загляданням вперед

Для перегляду виразу будь-яку комбінацію певних символів вказується шаблон за яким виявляється, але не повертається, збіг. Фактично, перегляд вперед визначає підвираз і тому формується окремо. Синтаксичний шаблон для перегляду вперед складається з підвиразу, перед яким стоїть ?=, а потім вміщується текст для співставлення.

Наприклад, є пароль, який має складатися не менше ніж з 7 символів і повинен обов'язково включати як мінімум одну велику букву та цифру. Це буде дещо складніше, оскільки користувач повинен мати можливість поставити велику букву на початку або в середині речення.

Для цього буде потрібний перегляд виразу з загляданням вперед. Крім того, потрібно розбити на групи знаків та обмежити його розміри від 8 до 22 знаків. Зокрема, регулярний вираз:

/^(?=._[a-z])(?=._[A-Z])(?=.\*\d)[a-zA-Z\d]{8,}$/

Текст:

Qwerty123

Im789098

weakpassword

Особливості обробки регулярних виразів у PHP

Для вивчення роботи регулярних виразів у PHP розглянемо функції офіційної документації PCRE (Perl Compatible Regular Expressions) яка доступна на офіційному сайті. Вираз має бути поміщений у роздільники, наприклад, у прямі слеші.

Роздільниками можуть бути довільні символи, крім алфавітно-цифрових, зворотного слеша '\' та нульового байта. Якщо символ роздільника зустрічається у шаблоні, його необхідно екранувати. Доступні комбінації роздільників, що прийшли з Perl:

(), {}, [].

Функції, що використовуються у PHP в пакеті PCRE для підтримки регулярних виразів:

· preg_grep() – шукає і повертає масив збігів.

· preg_match() – виконує пошук першого збігу за допомогою регулярних виразів.

· preg_match_all() – виконує глобальний пошук за допомогою регулярних виразів.

· preg_quote() – приймає шаблон та повертає його екрановану версію.

· preg_replace() – виконує операцію пошуку та заміни.

· preg_replace_callback() – теж виконує операцію пошуку та заміни, але використовують callback – функцію для будь-якої конкретної заміни.

· preg_split() – розбиває символьний рядок на підрядки.

Модифікатори

Для організації збігу без врахування регістру літер служить модифікатор i.

За допомогою модифікатора m можна активувати режим обробки багаторядкового тексту.

Замінні рядки можна обчислювати як PHP-код. Для активізації цього режиму служить модифікатор e .

У всіх функціях preg_replace() підтримується додатковий аргумент preg_replace_callback(), preg_split() який вводить обмеження на максимальну кількість замін або розбиття.

Зворотні посилання можуть позначатися за допомогою символу $ (наприклад $1), а в попередніх версіях замість знака $ застосовуються знаки \\.

Характерні для Perl Метасимволи \E, \l, \L, \u та \U не використовуються.

Функція preg_grep()

Функція preg_grep() – повертає масив входжень, які відповідають шаблону. Синтаксис функції:

preg_grep ( рядок $pattern , масив $array , int $flags= 0 ): масив | false

де pattern – рядок шаблону.

array – dхідний масив.

flags – у випадку, якщо встановлено PREG_GREP_INVERT, функція preg_grep() повертає ті елементи масиву, які не відповідають заданому шаблону pattern.

Функція preg_grep() Повертає масив, індексований ключами з масиву array або false у випадку помилки. Якщо переданий шаблон регулярного виразу не компілюється в допустимий регулярний вираз, видається помилка рівня E_WARNING.

Наприклад:

$fl_array = preg_grep("/^(\d+)?\.\d+$/", $array);

видасть всі елементи масиву, містять числа з плаваючою крапкою.

Функція preg_match()

Функція preg_match() – виконує перевірку на відповідність регулярному виразу. Синтаксис функції:

preg_match (

     рядок $pattern ,

     рядок $subject ,

     масив &$matches=null ,

     int $flags= 0 ,

     int $offset= 0

): int | false

де pattern – рядок шаблону.

subject – вхідний рядок.

matches – у випадку, якщо вказано додатковий параметр matches, він буде заповнений результатами пошуку. Елемент $matches[0] міститиме частину рядка, що відповідає входу всього шаблону, $matches[1] – частина рядка, що відповідає першій підмасці і так далі.

flags – може бути комбінацією прапорів:

PREG_OFFSET_CAPTURE. Якщо цей прапор вказано, то для кожного знайденого підрядка буде вказано позицію (в байтах) у вихідному рядку. Необхідно пам'ятати, що цей прапор змінює формат масиву, що повертається matches в масив, кожен елемент якого містить масив, що містить в індексі з номером 0 знайдений підрядок, а зміщення підрядки в параметрі subject – в індексі 1.

PREG_UNMATCHED_AS_NULL. Якщо цей прапор передано, несупадні підмаски будуть представлені значеннями null; інакше вони відображаються як порожніх рядків (string).

offset. Зазвичай пошук здійснюється зліва направо, з початку рядка. Можна використовувати додатковий параметр offset для вказівки альтернативної початкової позиції пошуку (в байтах).

preg_match() повертає 1, якщо параметр pattern відповідає переданому параметру subject, 0 – якщо ні. Або false при виникненні помилки.

Функція preg_match_all()

Функція preg_match_all() – Виконує глобальну перевірку регулярного виразу. Синтаксис функції:

preg_match_all (

     рядок $pattern ,

     рядок $subject ,

     масив &$matches=null ,

     int $flags= 0 ,

     int $offset= 0

): int | false

де pattern – шаблон для пошуку у вигляді рядка.

subject – вхідний рядок.

matches – масив усіх збігів у багатовимірному масиві, упорядкований відповідно до flags.

flags. Може бути комбінацією таких прапорів (зауважте, що це не має сенсу використовувати PREG_PATTERN_ORDER разом із PREG_SET_ORDER).

PREG_PATTERN_ORDER. Упорядковує результати так, що $matches[0] – це масив повних збігів шаблону, $matches[1] – це масив рядків, які відповідають першому підшаблону в дужках тощо.

PREG_SET_ORDER. Упорядковує результати таким чином, що $matches[0] – це масив першого набору збігів, $matches[1] – масив другого набору збігів тощо.

PREG_OFFSET_CAPTURE. Якщо цей прапор передано, для кожного знайденого збігу також повертатиметься зміщення додаткового рядка (у байтах). Зауважте, що це змінює значення matches на масив масивів, де кожен елемент є масивом, що складається з відповідного рядка зі зміщенням 0 і його зміщення рядка на subjectat offset 1.

PREG_UNMATCHED_AS_NULL. Якщо цей прапор передано, невідповідні підшаблони позначаються null. Інакше вони позначаються як порожній рядок. Якщо прапорець порядку не вказано, то передбачається PREG_PATTERN_ORDER.

offset. Зазвичай пошук починається з початку рядка теми. Необов'язковий параметр offset можна використовувати, щоб вказати альтернативне місце, з якого почати пошук (у байтах).

Примітка: Використання offset не є еквівалентним переходу substr($subject, $offset)до preg_match_all() замість рядка, оскільки pattern може містити твердження, ^ , $ або (?<=x).

Функція preg_match_all() повертає кількість повних збігів шаблону (яка може бути нульовою) або falseв при помилці.

Якщо переданий шаблон регулярного виразу не компілюється в дійсний регулярний вираз, то видається an E_WARNING.

Функція preg_quote()

Функція preg_quote() – вміщує символи регулярного виразу в лапки. Синтаксис функції:

preg_quote ( рядок $str , ? рядок $delimiter=null ): рядок

Функція preg_quote() приймає рядок str і ставить зворотну косу риску перед кожним символом, який є частиною синтаксису регулярного виразу. Це корисно, якщо є рядок часу виконання, якому потрібно знайти відповідність у тексті, і рядок може містити спеціальні символи регулярного виразу, зокрема:

. \ + \* ? [ ^ ] $ ( ) { } = ! < > | : – #

Зауважте, що / – це не спеціальний символ регулярного виразу.

Примітка: preg_quote() не призначена для застосування до $replacement рядка(ів) preg_replace() тощо.

Параметри:

str – вхідний рядок.

delimiter. Якщо вказано необов’язковий параметр delimiter, він також буде екранований. Це корисно для екранування роздільника, який вимагається функціями PCRE. / – це найпоширеніший роздільник. PCRE (Perl Compatible Regular Expressions) – бібліотека, що реалізує роботу регулярних виразів у стилі Perl (з деякими відмінностями).

Повертає екранований рядок у лапках.

Функція preg_replace()

Функція preg_replace() – виконує пошук і заміну регулярного виразу. Синтаксис функції:

preg_replace (

     рядок | масив $pattern ,

     рядок | масив $replacement ,

     рядок | масив $subject ,

     int $limit= -1 ,

     int &$count=null

): рядок | масив | нуль

Параметри функції:

pattern – шаблон для пошуку. Це може бути як рядок, так і масив із рядками. Також доступні кілька модифікаторів PCRE .

replacement. Рядок або масив із рядками для заміни. Якщо цей параметр є рядком, а pattern параметр є масивом, усі шаблони буде замінено цим рядком. Якщо обидва параметри pattern і replacement є масивами, кожен pattern буде замінено replacement відповідником. Якщо в масиві менше елементів, replacement ніж у pattern масиві, усі зайві patterns будуть замінені порожнім рядком.

replacementможе містити посилання у формі \n$n або \0$0, причому остання форма є кращою. Кожне посилання буде замінено текстом, охопленим n-тим шаблоном у дужках. n може бути від 0 до 99 і або посилається на текст, який відповідає всьому шаблону. Відкриваючі дужки рахуються зліва направо (починаючи з 1), щоб отримати номер підшаблону захоплення. Зауважте, що зворотні косі риски в рядкових літералах можуть потребувати екранування.

Під час роботи з шаблоном заміни, де зворотне посилання слідує безпосередньо за іншим числом (тобто: розміщення буквального числа відразу після відповідного шаблону), не можна використовувати звичну нотацію для свого зворотного посилання.

При використані застарілого модифікатора e ця функція екранує деякі символи (а саме ', ", \і NULL) у рядках, які замінюють зворотні посилання. Це робиться, щоб ґарантувати відсутність синтаксичних помилок через використання зворотного посилання з одинарними чи подвійними лапками (наприклад, 'strlen(\'$1\')+strlen("$2")').

subject – рядок або масив із рядками для пошуку та заміни. Якщо subject є масивом, то пошук і заміна виконується для кожного запису в subject, а повернуте значення також є масивом.

Якщо subject – це асоціативний масив, то ключі будуть збережені у поверненому значенні.

limit – максимальна кількість можливих заміни для кожного шаблону в кожному subject-рядку. За замовчуванням -1 – тобто без обмежень.

count – якщо вказано, то ця змінна буде заповнена кількістю виконаних замін.

Якщо параметр subject є масивом, то функція preg_replace() поверне масив, інакше вона поверне рядок.

Якщо знайдено збіги, то буде повернено новий subject, інакше буде повернено subject без змін або null якщо сталася помилка.

Використання модифікатора "\e" є помилкою, що суприводжуватиметься повідомленням класу E_WARNING. Якщо переданий шаблон регулярного виразу не компілюється в дійсний регулярний вираз, видається помилка класу E_WARNING.

Наприклад, заміна декількох значень

<?php

$patterns = array ('/(19|20)(\d{2})-(\d{1,2})-(\d{1,2})/',

                   '/^\s*{(\w+)}\s*=/');

$replace = array ('\3/\4/\1\2', '$\1 =');

echo preg_replace($patterns, $replace, '{startDate} = 1999-5-27');

 

Приклад виведе:

 

$startDate = 27.05.1999

 

Приклад використання параметра count:

 

$count = 0;

echo preg_replace(array('/\d/', '/\s/'), '*', 'xp 4 to', -1 , $count);

echo $count; //3

 

Приклад виведе:

 

xp***to

3

 

Функція preg_replace_callback()

 

Функція preg_replace_callback() – виконує пошук і заміну регулярного виразу за допомогою функції зворотного виклику. Синтаксис функції:

 

preg_replace_callback (

     рядок | масив $pattern ,

     виклик $callback ,

     рядок | масив $subject ,

     int $limit= -1 ,

     int &$count=null ,

     int $flags= 0

): рядок | масив | нуль

 

Параметри:

pattern – шаблон для пошуку. Це може бути як рядок, так і масив із рядками.

callback – pворотний виклик, який буде викликано та передано масиву відповідних елементів у subjectрядку. Зворотний виклик має повернути рядок заміни. Формат зворотного виклику:

 

обробник ( масив $matches ): рядок

 

callback-функція знадобиться для preg_replace_callback() лише в одному місці. Щоб оголосити зворотний виклик у виклику preg_replace_callback() можна використовувати анонімну функцію. Це дозволить отримати всю інформацію для виклику в одному місці та не захаращуєте простір імен функцій назвою функції зворотного виклику, яка більше ніде не використовується.

subject – рядок або масив із рядками для пошуку та заміни.

limit – максимально можливі заміни для кожного шаблону в кожному subject-рядку. За замовчуванням -1 – тобто без обмежень.

count – якщо вказано, то ця змінна буде заповнена кількістю зроблених замін.

flags – може бути комбінацією прапорів PREG_OFFSET_CAPTURE і PREG_UNMATCHED_AS_NULL, які впливають на формат масиву збігів.

Функція preg_replace_callback() повертає масив, якщо subject-параметр є масивом, або рядок в іншому випадку. При помилках повертається значення null. Якщо збіги знайдено, новий предмет буде повернено, інакше subject буде повернено без змін.

Якщо переданий шаблон регулярного виразу не компілюється в дійсний регулярний вираз, видається помилка класу E_WARNING.

Наприклад, preg_replace_callback() і анонімна функція:

 

/* a unix-style command line filter to convert uppercase

* letters at the beginning of paragraphs to lowercase */

$fp = fopen("php://stdin", "r") or die("can't read stdin");

while (!feof($fp)) {

    $line = fgets($fp);

    $line = preg_replace_callback(

        '|<p>\s*\w|',

        function ($matches) {

            return strtolower($matches[0]);

        },

        $line

    );

    echo $line;

}

fclose($fp);

 

Функція preg_split()

 

Функція preg_split() розбиває рядок за регулярним виразом. Синтаксис функції:

 

preg_split (

     рядок $pattern ,

     рядок $subject ,

     int $limit= -1 ,

     int $flags= 0

): масив | помилка

 

Параметри функції:

pattern – шаблон для пошуку у вигляді рядка.

subject – вхідний рядок.

limit – якщо вказано, то повертаються лише підрядки до limit, а решта рядка розміщується в останньому підрядку. Значення -1 або 0 означає "без обмежень".

flags – може бути будь-якою комбінацією прапорів у поєднанні з порозрядним оператором |. Прапори:

PREG_SPLIT_NO_EMPTY – якщо цей прапор встановлено, preg_split() повертатиме лише непорожні фрагменти.

PREG_SPLIT_DELIM_CAPTURE – якщо встановлено цей прапор, вираз у дужках у шаблоні роздільника також буде зафіксовано та повернено.

PREG_SPLIT_OFFSET_CAPTURE – якщо цей прапор встановлено, то для кожного збігу також повертатиметься зміщення додаткового рядка. Зауважте, що це змінює значення, що повертається в масиві, де кожен елемент є масивом, що складається з відповідного рядка зі зміщенням 0 і його зміщенням рядка на subjectat offset 1.

Функція preg_split() повертає масив, що містить підрядки, subject розділені вздовж меж, які відповідають pattern або false у разі помилки.

Якщо переданий шаблон регулярного виразу не компілюється в дійсний регулярний вираз, видається помилка E_WARNING.

 

Класи символів POSIX

 

POSIX (Portable Operating System Interface for uniX) – набір стандартів, які описують інтерфейси між операційною системою та застосунками, які також працюють у PHP. Вони загалом можуть підвищити читабельність регулярних виразів.

 

Таблиця 6 – Класи символів POSIX

Вираз
	

Призначення

[[:альнум:]]
	

Будь-яка буква англійського алфавіту чи цифра

[[:alpha:]]
	

Будь-яка буква ([a-zA-Z])

[[:пусто:]]
	

Пробільний символ або символ з кодом 0 та 255

[[:цифра:]]
	

Будь-яка цифра ([0-9])

[[:lower:]]
	

Будь-яка мала літера англійського алфавіту ([az])

[[:верхній:]]
	

Будь-яка велика літера англійського алфавіту ([AZ])

[[:point:]]
	

Будь-який знак пунктуації

[[:пробіл:]]
	

Будь-який символ пробілу

[[:xdigit:]]
	

Будь-яка шістнадцяткова цифра ([0-9a-fA-F])

 

Розглянемо приклад конкретної реалізації регулярних виразів в PHP, використовуючи подані реалізації. Зокрема, додано валідацію імені користувача, щоб він не зміг вводити занадто короткі поєднання букв:

 

     $pattern_name = '/\w{3,}/';

     $pattern_mail = '/\w+@\w+\.\w+/';

     $pattern_password = '/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d]{8,}$/';

    

     if (preg_match($pattern_name, $name) &&

         preg_match($pattern_mail, $mail) &&

         preg_match($pattern_password, $_POST['password'])) {

 # тут відбувається процедура реєстрації нового користувача

     }

 

Приклади регулярних виразів

 

Для тих, хто вивчає регулярні вирази, приклади – кращий підручник. Наведемо кілька, які показують їх широкі можливості при мінімумі зусиль.

 

Перевірка коректності e-mail адреси

Задача. Існує веб-сторінка, на якій у відвідувача запитується адреса email. Регулярний вираз має перевіряти правильність отриманої адреси перед надсиланням повідомлень. Перевірка не дає гарантії, що вказану поштову скриньку реально існує і приймає листи. Але відсіяти свідомо неправильні адреси вона може.

Рішення. Як і в будь-якій мові програмування, на PHP регулярні вирази email-перевірки адреси можуть бути реалізовані різними способами. Наведені приклади не є остаточним і єдиним варіантом. Тому в кожному випадку будемо наводити перелік вимог, які потрібно врахувати при записі виразу, а конкретна реалізація повністю залежить від розробника.

Отже, вираз, що перевіряє правильність email, повинен перевіряти наступні умови:

1.     Наявність у вихідному рядку символу @ та відсутність пробілів.

2.  Доменна частина адреси, після символу @, містить тільки допустимі для доменних імен символи. Такі самі вимоги до імені користувача.

3.  При перевірці імені користувача необхідно визначити наявність спеціальних символів, таких як апостроф або вертикальна риска. Такі символи відносяться до потенційно небезпечних і можуть міститися SQL-ін'єкціях. Слід уникати таких e-mail адрес.

4.  Імена користувача допускають наявність тільки однієї крапки, яка не може бути першим або останнім символом в рядку.

5.  Доменне ім'я повинне містити не менше двох і не більше шести символів.

Приклад, що враховує всі зазначені умови, можна побачити на рисунку 6.2.

 

php регулярні вирази email

Рисунок 6.2 – Регулярний вираз для перевірки e-mail адреси

 

Перевірка коректності URL-адрес

Задача. Перевірити, чи є заданий текстовий рядок коректною URL-адресою. Ще раз відзначимо, що регулярні вирази URL-перевірки можуть бути реалізовані різними способами.

Рішення. Наш підсумковий варіант виглядає наступним чином:

 

/^(https?://)?([da-z.-]+).([az.]{2,6})([/w .-] *) * /? $ /

 

Проаналізуємо його складові більш докладно, використовуючи рисунок 6.3.

 

регулярні вирази url

Рисунок 6.3 – Опис регулярного виразу для перевірки коректності

URL-адреси

 

Аналіз регулярного виразу по пунктах описаний в таблиці 6.2.

 

Таблиця 6.2 – Аналіз регулярного виразу для перевірки коректності

URL-адреси

№
	

Опис

1
	

Перед адресою URL не повинно бути ніяких символів

2
	

Перевіряємо наявність обов'язкового префікса «http»

3
	

Не повинно бути символів

4
	

Якщо присутній «s», то URL вказує на захищене з'єднання «https»

5
	

Обов'язковий фрагмент «//»

6
	

Немає символів

7-9
	

Перевірка правильності домену першого рівня і наявності крапки

10-13
	

Контроль правильності написання домену другого рівня і крапки

14-17
	

Файлова структура URL – набір цифр, букв, підкреслення, дефісів, крапок і слеш в кінці

 

Перевірка номерів кредитних карт

Задача. Необхідно реалізувати перевірку правильності номера пластикової карти найбільш поширених платіжних систем. Розглянуто варіант тільки для карт Visa і MasterCard.

Рішення. При створенні виразу необхідно враховувати можливу наявність у введеному номері пропусків. Цифри номера на карті розділені на групи для спрощення читання та диктування. Тому цілком природно, що людина може спробувати ввести номер використовуючи пропуски.

Написати універсальний вираз, що враховує можливі пропуски та дефіси, складніше, ніж просто відкинути всі символи, крім цифр. Тому у виразі рекомендується використовувати метасимвол /D, який видаляє всі символи, крім цифр.

Тепер можна переходити безпосередньо до перевірки номера. Всі компанії, що випускають кредитні картки, використовують унікальний формат номера. У прикладі це використовується, і клієнтові немає необхідності вводити найменування компанії – вона визначається за номером. Картки Visa завжди починаються з 4 і мають довжину номера в 13 або 16 цифр. MasterCard починається в діапазоні 51-55 з довжиною номера 16 цифр. У результаті отримуємо вираз наведений на рисунку 6.4.

 

Рисунок 6.4 – Регулярний вираз для перевірки правильності номера пластикової карти

 

Перед обробкою замовлення можна провести додаткову перевірку останньої цифри номера, яка обчислюється за алгоритмом Moon.

 

Перевірка телефонних номерів

Задача. Перевірка коректності введеного телефонного номера.

Рішення. Кількість цифр в стаціонарних і мобільних телефонних номерах значно різниться залежно від країни, тому універсально перевірити, використовуючи регулярні вирази, номер телефону на правильність неможливо. Але міжнародні номери мають строгий формат і відмінно підходять для перевірки за шаблоном. Тим більше що все більше національних телефонних операторів намагаються відповідати єдиному стандарту. Структура номера наступна:

 

+CCC.NNNNNNNNNNxEEEE,

 

де:

C – код країни, що складається з 1-3 цифр.

N – номер довжиною до 14 цифр.

E – необов'язкове розширення.

Плюс є обов'язковим елементом, а знак х присутній тільки при необхідності розширення.

В результаті маємо такий вираз:

 

^+[0-9]{1,3}.[0-9]{4,14}(?: x.+)?$

 

Числа в потрібному діапазоні

Задача. Необхідно забезпечити співпадіння цілого числа з певним діапазоном. Додатково необхідно за допомогою регулярного виразу знаходити тільки цифри з діапазону значень.

Рішення. В тіблиці 6.3 наведемо кілька виразів для декількох найбільш поширених випадків.

 

Таблиця 6.3 – Регулярні вирази для перевірки чисел на відповідність діапазонам

Призначення
	

Регулярний вираз

Визначаємо годину від 1 до 24
	

^(1[0-2]|[1-9])$

День всередині місяця 1-31
	

^(3[01]|[12][0-9]|[1-9])$

Секунда або хвилина 0-59
	

^[1-5]?[0-9]$

Число від 1 до 100
	

^(100|[1-9]?[0-9])$

День року 1-366
	

^(36[0-6]|3[0-5][0-9]|[12][0-9]{2}|[1-9][0-9]?)$

 

Перевірка [?]IP-адрес[/?]и

Задача. Необхідно визначити, чи є заданий рядок допустимою [?]IP-адрес[/?]ою у форматі IPv4 в діапазоні від 000.000.000.000 до 255.255.255.255.

Рішення. На мові PHP регулярний вираз для перевірки [?]IP-адрес[/?]и має декілька варіантів. Наприклад, наведений на рисунку 6.5.

регулярні вирази пробіл

Рисунок 6.5 – Регулярний вираз для перевірки [?]IP-адрес[/?]и

 

Використання регулярних виразів в форматі Perl

 

Найбільшої популярності отримали регулярні вирази в стилі Perl, які мають зовсім інший формат. Регулярні вирази Perl вкладаються між двома слешами. Наприклад, наступний шаблон відповідає слову hacker: "/hacker/". Після шаблону можуть зазначатися модифікатори в наступному вигляді:

 

/Шаблон/модифікатори

 

Модифікаторами є літери, які впливають на регулярний вираз. Найбільш популярними модифікаторами Perl є "i" та "x". Розглянемо їх на прикладах.

·      i – ігнорувати регістр букв. Це означає, що регулярний вираз "/Hacker/i" буде відповідати словами hacker, HACKER, HacKer і т.д.

·      x – ігнорувати в шаблоні пробіли, переклади рядків і коментарі. Це дозволяє використовувати в шаблоні коментарі для покращення читабельності коду.

·      m – за замовчуванням текст розглядається як один рядок, але якщо вказаний цей модифікатор, то можна використовувати багаторядковий текст.

 

Можна вказувати відразу кілька модифікаторів

 

У регулярних виразах Perl дуже важливе значення має зворотній слеш. З наступного списку можна побачити різні варіанти використання цього символу.

·      \b – межа слова;

·      \B – відсутність межі слова;

·      \A<strong> – початок рядка;

·      \Z – кінець рядка або переклад каретки;

·      \z – кінець рядка;

·      \d – десяткова цифра;

·      \D – будь-який символ, крім десяткової цифри;

·      \s – пропуск або символ табуляції;

·      \S – все, крім пробілу;

·      \n – символ перекладу каретки (символ з кодом 13);

·      \r – символ повернення каретки (символ з кодом 10);

·      \t – символ табуляції (символ з кодом 9);

·      \w – символ, який використовується в словах, букви, цифри і підкреслення;

·      \W – все, крім символів, використовуваних в словах;

·      \xhh – дозволяє задати символ через його шістнадцятковий код. Наприклад, для завдання латинської літери A потрібно написати "\x41".

Символ "\" має спеціальне значення, але якщо необхідно використати цей символ, то слід вказати його двічі.

Приклад. Припустимо, що нам потрібно вказати три послідовно розміщенні цифри. Для цього можна використовувати наступний регулярний вираз:

 

/\d\d\d/

 

Те ж саме можна записати інакше:

 

/\d{3}/

 

Тепер подивимося, як можна створити шаблон з цифри, букви і цифри:

 

/\d\w\d/

 

Ускладнимо завдання. Припустимо, що необхідно знайти рядок, в якому спочатку йдуть від 3 до 5 символів, потім пробіл і далі від 3 до 7 цифр. У вигляді регулярного вираження це буде виглядати наступним чином:

 

/[A-Z]{3,5}\s\d{3,7}

 

Як і в регулярних виразах PHP, в Perl-шаблонах можна використовувати крапку, яка означає будь-який одинарний символ.

У регулярних виразах Perl можна використовувати квадратні дужки для завдання діапазону можливих значень. Ось регулярний вираз, який відповідає будь-яким цифрам і заголовних букв:

 

/[0-9A-Z]/

 

Наступний приклад показує, як замінити в рядку символи, що входять до діапазону, на символ "Х" за допомогою функції preg_replace():

 

$text = "df2345@sdfsdfsd334df";

$newtext = preg_replace("/[0-9A-Z]/","X",$text);

echo $newtext;

 

Символ "^" означає заперечення. Якщо необхідно замінити на символ "Х" все, крім цифр 1, 2 і 3, то використовуємо шаблон /[^123]/:

 

$newtext = preg_replace("/[^123]/","X",$text);

 

Робота з регулярними виразами в стилі Perl і PHP дуже схожа.

 

Функції для обробки регулярних виразів Perl

 

Познайомимося з функціями для роботи з регулярними виразами Perl. Ці функції відрізняються від розглянутих вище, але деякі дуже схожі.

 

Функція Preg_match

Функція шукає в рядку відповідність регулярному виразу, як функція ereg() для регулярних виразів PHP. У загальному вона виглядає наступним чином:

 

int preg_match( string pattern, string subject [, Array matches])

 

У функції три параметри, перші два з яких є обов'язковими:

·      pattern – регулярний вираз;

·      subject – рядок, в якому відбувається пошук;

·      matches – змінна, в яку буде поміщений масив знайдених значень.

Якщо регулярний вираз розбити на частини за допомогою круглих дужок, то рядок розбивається відповідно до регулярного виразу і поміщається в масив. Нульовий елемент масиву – копія рядка.

Ця функція дуже зручна для перевірки, чи відповідає рядок певному шаблону. Наприклад, якщо потрібно перевірити відповідність змінної $text шаблоном електронної поштової адреси, то можна виконати наступного код:

 

$r=preg_match("/^([a-zA-Z0-9\._\-]+@[a-zA-Z0-9\._\-]+(\.[a-zA-Z0-9]+)+)*$/",$text);

if(!$r){

exit( "Помилка формату поштової скриньки");

}

 

Функція Preg_match_all

Функція preg_match_all() працює як preg_match(), але при цьому дозволяє задати порядок, в якому шукаються відповідні шаблону підрядки. У загальному вигляді функція виглядає наступним чином:

 

int preg_match_all(string pattern,string subject,array matches[,Int order])

 

У функції чотири параметри, перші три з яких є обов'язковими:

·      pattern – регулярний вираз;

·      subject – рядок, в якому відбувається пошук;

·      matches – змінна, в яку буде поміщений масив знайдених значень. Якщо регулярний вираз розбити на частини за допомогою круглих дужок, то кожен елемент масиву буде містити знайдену відповідність певній дужці регулярного виразу;

·      order – порядок розміщення рядків в результуючому масиві. Цей параметр може приймати значення:

PREG_PATERN_ORDER – нульовий елемент буде масивом повного відтворення шаблону. Інші елементи відповідають знайденим підрядками згідно розбитим дужках;

PREG_SET_ORDER – результати пошуку будуть знаходитися в масиві matches, починаючи з нульового символу.

Якщо відповідність знайдено, то функція поверне true, інакше результат буде дорівнювати false.

 

Функція Preg_split

Функція preg_split() розбиває рядок на частини відповідно до регулярного виразу і повертає масив рядків, як функція split() для PHP. У загальному вона виглядає так:

 

array preg_split(string pattern,string subject[,Int limit[,Int flags]])

 

Розглянемо параметри функції:

·      pattern – регулярний вираз;

·      subject – рядок, в якому відбувається пошук;

·      limit – обмеження кількості знайдених значень;

·      flags – тут можна вказати PREG_SPLIT_NO_EMPTY. В цьому випадку функція поверне тільки непусті рядки.

 

Онлайн-перевірка виразів

Перевірка правильності синтаксису регулярних виразів для програмістів початківців може бути проблематичною через складність синтаксису. Для вирішення такої проблеми існує багато онлайн-тестерів виразів, що дозволяють легко перевірити правильність створеного шаблону на реальному прикладі. Програміст вводить вираз і дані для перевірки та одразу бачить результат обробки. Зазвичай там само присутній довідковий розділ, де докладно описуються регулярні вирази та приклади реалізації для найбільш поширених мов програмування.

Але беззаперечно довіряти результатам онлайн-сервісів не рекомендується. Регулярний вираз, написаний і перевірений особисто, підвищує кваліфікацію і гарантує відсутність помилок.

Використовуйте регулярні вирази для перевірки введених користувачем даних або для здійснення заміни. Який саме метод вибрати, залежить від особистих переваг і ситуації. Іноді зручніше і простіше написати PHP-регулярний вираз, а іноді Perl. Але необхідно слідкувати за документацією мови щодо актуальності використовуваних функцій.

 

Завдання

Розробити веб-документи для перевірки регулярного виразу згідно варіанту завдання. Завдання вивести у веб-документі у вигляді рисунка. Обчислені значення вивести в окремих блоках div. У веб-документі засобами PHP додатково вивести інформацію про розробника (група, прізвище, ім’я, по батькові), дату створення документу, поточну дату.

Розробити форму та обробник для введення інформації з використанням полів наступних типів: button, checkbox, file, hidden, password, radio, reset, submit та text. Кількість полів повинна бути рівна сумі двох останніх цифр варіанту. Якщо сума менше 10 її слід збільшити на 10. В PHP-обробнику використати регулярні вирази для перевірки всіх даних отриманих від користувача.

Веб-документи зберегти та розмістити в окремому каталозі на хостингу, зареєстрованому в лабораторній роботі №2 з попереднього семестру.
