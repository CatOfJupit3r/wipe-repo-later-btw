Тема. Обробка масивів засобами PHP. Двомірні масиви

Мета: Ознайомлення з основними операціями над массивами (сортування, перевертання, операції з списком). Набуття навичок виконання операцій з ключами та значеннями масивів. Ознайомлення з особливостями роботи з массивами та опрацюванням складених та багатовимірних масивів.

Теоретичні відомості

Фукції для роботи з масивами і операції над масивами

Розглянемо деякі часто використовувані функції для роботи з масивами.

Функція list()

Припустимо, у нас є масив, що складається з трьох елементів:

$names[0]="Олександр";

$names[1]="Микола";

$names[2]="Яків";

Припустимо, в якийсь момент нам потрібно передати значення всіх трьох елементів масиву, відповідно трьом змінним: $alex, $nick, $yakov. Це можна зробити так:

$alex=$names[0];

$nick=$names[1];

$yakov=$names[2];

Якщо масив великий, то такий спосіб привласнення елементів масиву змінним не дуже зручний. Є більш раціональний підхід – використання функції list() :

list ($alex, $nick, $yakov)=$names;

Якщо нам потрібні тільки "Микола" і "Яків", то ми можемо зробити так:

list (, $nick, $yakov)=$names;

Функція array()

Функція Array() використовується спеціально для створення масивів. При цьому вона дозволяє створювати порожні масиви. Ось методи використання функції Array():

//Створює порожній масив:

$arr=array();

//Створює список з трьома елементами. Індекси починаються з

//нуля:

$arr2=array("Іваненко","Петренко","Сидоренко");

//Створює асоціативний масив з трьома елементами:

$arr3=array("Іваненко"=>"Іван", "Петренко"=>"Петро",

"Сидоренко"=>"Сидор");

//Створює багатовимірний асоціативний масив:

$arr4=array("name"=>"Іваненко", "age"=>"24",

"email"=>"ivanenko@ukr.net");

$arr4=array("name"=>"Петренко", "age"=>"34",

"email"=>"petrenko@ukr.net");

$arr4=array("name"=>"Сидоренко", "age"=>"47",

"email"=>"sidorenko@ukr.net");

Операції над масивами

Сортування масивів

Почнемо з найпростішого – сортування масивів. У PHP для цього існує дуже багато функцій. З їх допомогою можна сортувати асоціативні масиви і списки в порядку зростання або зменшення, а також в тому порядку, в якому вам необхідно – за допомогою користувальницької функції сортування.

Сортування масиву за значеннями c допомогою функцій asort() і arsort():

Функція asort() сортує масив, вказаний в її параметрі, так, щоб його значення йшли в алфавітному (якщо це рядки) або в зростаючому (для чисел) порядку.

При цьому зберігаються зв'язку між ключами і відповідними їм значеннями, т. Е. Деякі пари ключ => значення просто "спливають" вгору, а деякі – навпаки, "опускаються". наприклад:

$A=array("a"=>"Zero","b"=>"Weapon","c"=>"Alpha","d"=>"Processor");

asort($A);

foreach($A as $k=>$v) echo "$k=>$v ";

//виводить "c=>Alpha d=>Processor b=>Weapon a=>Zero"

//як бачимо, змінився тільки порядок пар ключ => значення

Функція arsort() виконує те ж саме, за одним винятком: вона впорядковує масив не по зростанню, а по спадаючій.

Сортування по ключам за допомогою функцій ksort() і krsort():

Функція ksort() практично ідентична функції asort(), з тією різницею, що сортування здійснюється не за значеннями, а по ключам (в порядку зростання). Наприклад:

$A=array("d"=>"Zero", "c"=>"Weapon", "b"=>"Alpha", "a"=>"Processor");

ksort($A);

for(Reset($A); list($k,$v)=each($A);) echo "$k=>$v ";

//виводить "a=>Processor b=>Alpha c=>Weapon d=>Zero"

Функція для сортування за ключам у зворотному порядку називається krsort() і застосовується точно в такому ж контексті, що і ksort().

Сортування по ключам за допомогою функції uksort():

Досить часто нам доводиться сортувати щось за більш складного критерію, ніж просто за алфавітом. Наприклад, нехай в $Files зберігається список імен файлів і підкаталогів в поточному каталозі. Можливо, ми захочемо вивести цей список не тільки в лексикографічному порядку, але також і щоб все каталоги передували файлам. У цьому випадку нам варто скористатися функцією uksort(), написавши попередньо функцію порівняння з двома параметрами, як того вимагає uksort().

//Ця функція повинна порівнювати значення $ f1 і $ f2 і

//повертати:

//-1, если $f1<$f2,

//0, если $f1==$f2

//1, если $f1>$f2

//Під <і> розуміється проходження цих імен в виведеному списку

function FCmp($f1,$f2)

{ //Каталог завжди передує файлу

if(is_dir($f1) && !is_dir($f2)) return -1;

//Файл завжди йде після каталогу

if(!is_dir($f1) && is_dir($f2)) return 1;

//Інакше порівнюємо лексикографічно

if($f1<$f2) return -1; elseif($f1>$f2) return 1; else return 0;[/font>

}

//Нехай $ Files містить масив з ключами - іменами файлів

//в поточному каталозі. Відсортуємо його.

uksort($Files,"FCmp");//передаємо функцію сортування "за

//посиланням"

Звичайно, зв'язку між ключами і значеннями функцією uksort() зберігаються, т. Е., Знову ж таки, деякі пари просто "спливають" вгору, а

інші – "осідають".

Сортування за значеннями за допомогою функції uasort()

Функція uasort() дуже схожа на uksort(), з тією різницею, що

змінною (користувальницької) функції сортування "підсуваються» не ключі, а чергові значення з масиву. При цьому також зберігаються зв'язку в парах ключ => значення.

Перевертання масиву за допомогою функції array_reverse()

Функція array_reverse() повертає масив, елементи якого слідують в зворотному порядку щодо масиву, переданого в параметрі. При цьому зв'язку між ключами і значеннями, звичайно, не втрачаються. Наприклад, замість того, щоб ранжувати масив у зворотному порядку за допомогою arsort(), ми можемо впорядкувати його в прямому порядку, а потім перевернути:

$A=array("a"=>"Zero","b"=>"Weapon","c"=>"Alpha","d"=>"Processor");

asort($A);

$A=array_reverse($A);

Звичайно, зазначена послідовність працює довше, ніж один-єдиний виклик arsort().

Сортування списку за допомогою функцій sort() і rsort()

Ці дві функції призначені в першу чергу для сортування списків.

Функція sort() сортує список (зрозуміло, за значеннями) в порядку зростання, а rsort() – в порядку убування. Приклад для функції sort():

$A=array("40", "20", "10", "30");

sort($A);

for($i=0; $i<count($A); $i++) echo "$A[$i]"."<br>";

//виводить 10 20 30 40

Перемішування списку за допомогою функції shuffle()

Функція shuffle() "перемішує" список, переданий їй першим параметром, так, щоб його значення розподілялися випадковим чином. Зверніть увагу, що, по-перше, змінюється сам масив, а по-друге, асоціативні масиви воспріімаются як списки. приклад:

$A=array(10,20,30,40,50);

shuffle($A);

foreach($A as $v) echo "$v ";

Наведений фрагмент коду виводить числа 10, 20, 30, 40 і 50 у випадковому порядку.

Виконавши цей фрагмент кілька разів, ви можете виявити, що від запуску до запуску черговість проходження чисел не змінюється. Ця властивість обумовлена тим, що функція shuffle() використовує стандартний генератор випадкових чисел, який перед роботою необхідно ініціалізувати при допомозі виклику srand().

Операції з ключами і значеннями масиву

Функція array_flip()

array_flip(array $arr)

Функція array_flip() "пробігає" по масиву і змінює місцями його ключі і значення. Вихідний масив $arr не змінюється, а результуючий масив просто повертається. Звичайно, якщо в масиві були присутні кілька елементів з однаковими значеннями, враховуватися буде тільки останній з них:

$A=array("a"=>"aaa", "b"=>"aaa", "c"=>"ccc");

$A=array_flip($A);

//тепер $A===array("aaa"=>"b", "ccc"=>"c");

Функція array_keys()

array_keys (array $arr [, mixed $SearchVal])

Функція array_keys() повертає список, що містить всі ключі масиву $arr. Якщо заданий необов'язковий параметр $SearchVal, то вона поверне тільки ті ключі, яким відповідають значення $SearchVal.

Фактично, ця функція із заданим другим параметром є зворотною по відношенню до оператора [] – витяганню значення за його ключу.

Функція array_values()

array_values(array $arr)

Функція array_values() повертає список всіх значень в асоціативному масиві $arr. Очевидно, така дія марно для списків, але іноді виправдано для хешей.

Функція in_array()

in_array (mixed $val, array $arr)

Функція in_array() повертає true, якщо елемент зі значенням $val присутній в масиві $arr. Втім, якщо вам часто доводиться проробляти цю операцію, подумайте: чи не краще буде скористатися асоціативним масивом і зберігати дані в його ключах, а не в значеннях? На цьому ви можете сильно виграти у швидкодії.

Функція array_count_values()

array_count_values (list $List)

Функція array_count_values() підраховує, скільки разів кожне значення зустрічається в списку $List, і повертає асоціативний масив з ключами – елементами списку і значеннями – кількістю повторів цих елементів. Іншими словами, функція array_count_values() підраховує частоту появи значень в списку $List. приклад:

$List=array(1, "hello", 1, "world", "hello");

array_count_values($array);

//повертає array(1=>2, "hello"=>2, "world"=>1)

Злиття масивів

Злиття (конкатенація) масивів – це операція створення масиву, що складається з елементів декількох інших масивів. Злиття масивів – це дуже небезпечна операція, оскільки результат злиття керується своєю логікою, забувши про яку можна втратити дані. Злиття масивів реалізується за допомогою оператора " + " або за допомогою функції array_merge().Злиття списків може здійснюватися тільки за допомогою функції array_merge(). Припустимо, ми маємо два масиви:

$A=array("1"=>"Первый", "2"=>"Второй");

$B=array("3"=>"Третий", "4"=>"Четвертый");

Тепер злиємо дані два масиви в один масив $C :

$C=$A + $B;

Оператор " + " для масивів не коммутативний. Це означає, що $A + $B не дорівнює $B + $A.

В результаті розглянутого прикладу ми отримаємо масив $C такого вигляду:

"1"=>"Перший", "2"=>"Другий", "3"=>"Третій", "4"=>"Четвертий"

А в результаті $B + $A ми отримаємо такий масив:

"3"=>"Третій", "4"=>"Четвертий", "1"=>"Перший", "2"=>"Другий"

При злитті списків такий метод не працює. Пояснимо даний факт на прикладі. Припустимо, у нас є два масиви:

$A=array(10,11,12);

$B=array(13,14,15);

В результаті злиття списків $A і $B ($A + $B) ми отримаємо: 10,11,12. А це зовсім не той результат, який ми хотіли отримати. Пов'язано це з тим, що при злитті списків з однаковими індексами в результуючому масиві залишається елемент першого масиву, причому на тому ж місці. У такому випадку нам необхідно використовувати функцію array_merge().

Функція array_merge()

Функція array_merge() покликана усунути всі недоліки, властиві оператору " + " для злиття масивів. А саме, вона зливає масиви, перераховані в її аргументах, в один великий масив і повертає результат. Якщо в масивах зустрічаються однакові ключі, в результат поміщається пара ключ => значення з того масиву, який розташований правіше в списку аргументів. Однак це не зачіпає числові ключі: елементи з такими ключами поміщаються в кінець результуючого масиву в будь-якому випадку.

Таким чином, за допомогою array_merge() ми можемо позбутися від усіх недоліків оператора " + " для масивів. Ось приклад, що зливає два списки в один:

$L1=array(100,200,300);

$L2=array(400,500,600);

$L=array_merge($L1,$L2);

//тепер $L===array(100,200,300,400,500,600);

Завжди використовуйте цю функцію, якщо вам потрібно працювати саме зі списками, а не зі звичайними асоціативними масивами.

Отримання частини масиву

Для отримання частини масиву можна використовувати функцію array_slice():

array_slice (array $Arr, int $offset [, int $len])

Ця функція повертає частину асоціативного масиву, починаючи з пари ключ => значення зі зміщенням (номером) $offset від початку і довжиною $len (якщо останній параметр не заданий – до кінця масиву).

Параметри $offset і $len задаються по точно таким же правилам, як і аналогічні параметри в функції substr(). А саме, вони можуть бути негативними (в цьому випадку відлік здійснюється від кінця масиву), і т. Д. Ось кілька прикладів:

$input=array ("a", "b", "c", "d", "e");

$output=array_slice ($input, 2); //"c", "d", "e"

$output=array_slice ($input, 2, -1); //"c", "d"

$output=array_slice ($input, -2, 1); //"d"

$output=array_slice ($input, 0, 3); //"a", "b", "c"

Вставка і видалення елементів масивів

Ми вже знаємо декілька операторів, які відповідають за вставку і видалення елементів. Наприклад, оператор [] (порожні квадратні дужки) додає елемент в кінець масиву, привласнюючи йому числовий ключ, а оператор Unset() разом з витягом по ключу видаляє потрібний елемент. Мова PHP підтримує і багато інших функцій, які іноді буває зручно використовувати.

array_push (alist & $Arr, mixed $var1 [, mixed $var2,...])

Ця функція додає до списку $Arr елементи $var1, $var2 і т. Д. Вона присвоює їм числові індекси – точно так само, як це відбувається для стандарних []. Якщо вам потрібно додати всього один елемент, напевно, простіше і буде скористатися цим оператором:

array_push($Arr,1000); //викликаємо функцію…

$Arr[]=100; //те ж саме, але коротше

Зверніть увагу, що функція array_push() сприймає масив, як стек, і додає елементи завжди в його кінець. Вона повертає нове число елементів в масиві.

Функція array_pop()

array_pop (list & $Arr)

Функція array_pop(), є протилежністю array_push(), знімає елемент з "вершини" стека (тобто бере останній елемент списку) і повертає його, видаливши після цього його з $Arr. За допомогою цієї функції ми можемо будувати конструкції, що нагадують стек. Якщо список $Arr був порожній, функція повертає порожній рядок.

Функція array_unshift

array_unshift (list & $Arr, mixed $var1 [, mixed $var2,...])

Функція array_unshift дуже схожа на array_push(), але додає перераховані елементи не в кінець, а в початок масиву.При цьому порядок проходження $var1, $var2 і т. Д. Залишається тим же, т. Е. Елементи як би "вдвигаются" в список зліва. Новим елементам списку, як зазвичай, призначаються числові індекси, починаючи з 0 ; при цьому всі ключі старих елементів масиву, які також були числовими, змінюються (найчастіше вони збільшуються на число значень, що вставляються). Функція повертає новий розмір масиву. Ось приклад її застосування:

$A=array(10,"a"=>20,30);

array_unshift($A,"!","?");

//тепер $A===array(0=>"!", 1=>"?", 2=>10, a=>20, 3=>30)

Функція mixed array_shift

mixed array_shift (list & $Arr)

Функція mixed array_shift витягує перший елемент масиву $Arr і повертає його. Вона сильно нагадує array_pop(), але тільки отримує початковий, а не кінцевий елемент, а також виробляє досить сильну "струс" всього масиву: адже при витяганні першого елементу доводиться коректувати всі числові індекси у всіх елементів, що залишилися.

Функція array_unique()

array_unique (array $Arr)

Функція array_unique() повертає масив, складений з усіх унікальних значень масиву $Arr разом з їх ключами. У результуючий масив поміщаються перші зустрілися пари ключ => значення:

$input=array("a" => "green", "red", "b" => "green", "blue", "red");

$result=array_unique($input);

//тепер $result===array("a"=>"green", "red", "blue");

array_splice (array & $Arr, int $offset [, int $len] [, int $Repl])

Функція array_splice, також як і array_slice(), повертає підмасив $Arr, починаючи з індексу $offset максимальної довжини $len, але, разом з тим, вона робить і іншу корисну дію. А саме, вона замінює тільки що вказані елементи на те, що знаходиться в масиві $Repl (або просто видаляє, якщо $Repl не вказано). Параметри $offset і $len задаються так само, як і у функції substr() – а саме, вони можуть бути і негативними, в цьому випадку відлік починається від кінця масиву. Ось деякі приклади:

$input=array("red", "green", "blue", "yellow");

array_splice($input,2);

//Тепер $input===array("red", "green")

array_splice($input,1,-1);

//Тепер $input===array("red", "yellow")

array_splice($input, -1, 1, array("black", "maroon"));

//Тепер $input===array("red", "green", "blue", "black", "maroon")

array_splice($input, 1, count($input), "orange");

//Тепер $input===array("red", "orange")

Останній приклад показує, що як параметр $Repl ми можемо вказати і звичайне, строкове значення, а не масив з одного елемента.

Змінні і масиви

Функція compact()

compact (mixed $vn1 [, mixed $vn2,...])

Функція compact() упаковує в масив змінні з поточного контексту (глобального чи контексту функції), задані своїми іменами в $vn1, $vn2 і т. Д. При цьому в масиві утворюються пари з ключами, рівними вмісту $vnN, і значеннями відповідних змінних. Ось приклад використання цієї функції:

$a="Test string";

$b="Some text";

$A=compact("a","b");

//тепер $A===array("a"=>"Test string", "b"=>"Some text")

Чому ж тоді параметри функції позначені як mixed ? Справа в тому, що вони можуть бути не тільки рядками, а й списками рядків. У цьому випадку функція послідовно перебирає всі елементи цього списку, і упаковує ті змінні з поточного контексту, імена яких вона зустріла. Більш того – ці списки можуть, в свою чергу, також містити списки рядків, і т. Д. Правда, останнім використовується порівняно рідко, але все ж ось приклад:

$a="Test";

$b="Text";

$c="CCC";

$d="DDD";

$Lst=array("b",array("c","d"));

$A=compact("a",$Lst);

//тепер $A===array("a"=>"Test", "b"=>"Text", "c"=>"CCC", "d"=>"DDD")

Функція extract()

extract (array $Arr [, int $type] [, string $prefix])

Функція extract() виробляє дії, прямо протилежні compact(). А саме, вона отримує в параметрах масив $Arr і перетворює кожну його пару ключ => значення в змінну поточного контексту.

Створення списку – діапазону чисел

range (int $low, int $high)

Ця функція дуже проста. Вона створює список, заповнений цілими числами від $low до $high включно.

Лічильник елементів масиву

Для підрахунку елементів масиву призначена функція count().

Приклад використання функції count():

$arr[]=5;

$arr[]=4;

$arr[]=8;

$arr[]=3;

$arr[]=8;

echo "<h2>Число елементів масиву: ".count($arr)."</h2>";

//Виводить: Число элементів масиву: 5

Видалення масиву і його елементів

Якщо ви хочете видалити масив цілком, скористайтеся функцією unset(). Якщо ви хочете видалити пару ключів / значення, ви також можете використовувати функцію unset(). Наведемо конкретні приклади:

$arr=array(5 => 1, 12 => 2);

$arr[]=56; //У цьому місці скрипта це

                //еквівалентно $arr[13]=56;

$arr["x"]=42; //Це додає до масиву новий

                //елемент з ключем "x"

unset($arr[5]); //Це видаляє елемент з масиву

unset($arr); //Це видаляє масив повністю

Деякі особливості роботи з масивами

Перетворення в масив (тип array)

Для будь-якого з типів: integer, float, string, boolean і resource, якщо ви перетворите значення в масив, ви отримаєте масив з одним елементом (з індексом 0), що є скалярним значенням, з якого ви почали.

Якщо ви перетворите в масив об'єкт ( object ), ви отримаєте в якості елементів масиву властивості (змінні-члени) цього об'єкта. Ключами будуть імена змінних-членів.

Якщо ви перетворите в масив значення NULL, ви отримаєте порожній масив.

Порівняння масивів

Масиви можна порівнювати за допомогою функції array_diff() і операторів масивів (див. таблицю 5.1).

Таблиця 5.1 – Оператори, що працюють з масивами

Приклад

Назва

Результат

$ A + $ b

об'єднання

Об'єднання масиву $ a і масиву $ b.

$ A == $ b

Так само

TRUE в разі, якщо $ a і $ b містять одні й ті ж елементи.

$ A === $ b

тотожно дорівнює

TRUE в разі, якщо $ a і $ b містять одні й ті ж елементи в тому ж самому порядку.

$ A! = $ B

Не дорівнює

TRUE якщо масив $ a НЕ дорівнює масиву $ b.

$ A <> $ b

Не дорівнює

TRUE якщо масив $ a НЕ дорівнює масиву $ b.

$ A! == $ B

Тотожно не дорівнює

TRUE якщо масив $ a НЕ дорівнює тотожно масиву $ b.

Приклад порівняння масивів PHP:

$a = array("apple", "banana");

$b = array(1 => "banana", "0" => "apple");

var_dump($a == $b); // bool(true)

var_dump($a === $b); // bool(false)

Завдання

Створити web-документ для для розв’язування задачі відповідного варіанта згідно з умовою. Варіант вибирається відповідно до вашого номера в журналі). Для зберігання наборів проміжних значень використати масиви. Вхідною інформацією є знання однієї з матриць:

D = [
[0.2, -7.1, -3.5, 4.1],
[2.4, -1.7, 3.1, 2.2],
[-8.3, 4.1, -2.2, -1.7]
]

Завдання вивести у web-документі у вигляді рисунка.

Обчислені значення вивести в окремих блоках div.

У web-документі засобами PHP додатково вивести інформацію про розробника (група, прізвище, ім’я, по батькові), дату створення документу, поточну дату.

Web-документ зберегти та розмістити в окремому каталозі на хостингу, зареєстрованому в лабораторній роботі №2 з попереднього семестру.

Варіанти задач:

У матриці D знайти максимальний від’ємний елемент більший за – 10, кожний елемент матриці D піднести до квадрату в іншому випадку з кожного елементу матриці D добути корінь кубічний. Обчислити добуток елементів першого і другого рядків та суму елементів першого та другого і другого стовпчиків нової матриці. Визначити в них менше значення і піднести його до 5 степеня.
